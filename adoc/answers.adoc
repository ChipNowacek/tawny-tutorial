
== Can I add annotations on axioms?

* OWL allows annotation of axioms, for provenance for example
* Tawny provides a syntax for this
* Annotates `SubClassOf` axiom between `Man` and `Person` with a comment.
* http://www.russet.org.uk/blog/3028

[source,lisp]
----
(defclass Man
 :super
 (annotate Person
           (owl-comment "States that every man is a person")))
----

ifndef::backend-slidy[]
[NOTE]
====
One of the reasons for the complexity of the OWL API is that it allows
annotations to be passed in lots of places, including on the axioms that
assert the relationship between, for example, two classes. One simplification
I made with Tawny is to hide this complexity. Moreover, Tawny is frame-centric
so the axioms are not normally seen explicitly.

Unfortunately, it appears that in hiding the complexity, I had also hidden a
capability that people actually use: GO uses axiom annotations for provenance
for instance. So I have added this capability into tawny with a slightly
expanded syntax.

The `annotate` function returns an object encapsulating and OWL API entity and
an annotation that will be added to the axiom of the frame. We can see this in
the example given. Note that we are annotating neither `Person` nor `Man` in
this case, but the relationship between them.
====
endif::backend-slidy[]

== How does this affect ontology deployment

* Potentially none -- Tawny generates an OWL file
* Potentially automatable
** In project source, or through leiningen plugin
* Or can publish as a maven artefact
** Ontology can be downloaded as a software artefact
** Separates out ontology identifier and download location

ifndef::backend-slidy[]
[NOTE]
====
We can deploy ontologies to bioportal or to anywhere else exactly as we do
now. Save the OWL file, and do stuff to it manually.

Of course, in a programmable environment, it is also very easy to add
additional deployment technology -- so generate one or more files, copy them
to another location, via ssh or http, check them in somewhere. This can be
achieved either in the project source or as a leiningen plugin.

Or, finally, we can deploy our ontology like any other piece of Clojure code,
as a maven artifact, to maven central, to clojars (like maven central but for
Clojure), or to our own private repo. This also separates our the ontology
identifier from the download location. It's possible to argue whether this is
a good thing or a bad thing.
====
endif::backend-slidy[]


== How do you version your ontology?

* Tawny-OWL uses a line-orientated syntax
* You edit *source code* not a visualisation of an XML file
* Like various OBO flat file syntaxes, it works well in git or any VCS
* Leiningen supports release versioning, using Semantic Versioning

ifndef::backend-slidy[]
[NOTE]
====
Tawny-OWL uses a line-orientated syntax and what you edit is source code, not
some XML that has been generated. So, it works very well with version control.
The serialisation order is entirely predictable because there is not
serialisation -- it's source code, it only changes if you edit it.

Working with source code also means that diff tools show you changes in the
same form of the code that you edit, so it's very easy to compare two
versions, two branches what ever. The only exception to this are the EDN files
used for numeric IDs of OBO identifiers. These have been designed to version
well (they are generated but not regeneratable, so should be regarded a source
code), but only time will tell. "They do not version well" will be considered
to be a bug though, and will be something I would want to fix.

We've used git for all the various ontologies we have developed, and it works
nicely.

It is also possible to version in the sense of release tagged versions of an
ontology and to use a dependency mechanism.
====
endif::backend-slidy[]

== How do you test your ontology

* Clojure supports one or more unit tests frameworks
* We use the default (core.test) framework
* Tawny-OWL provides some fixtures
* Also use spreadsheet generated testing
** Paper – http://arxiv.org/abs/1505.04112
** Tawny-Karyotype – http://github.com/jaydchan/tawny-karyotype
** Plain English Summary - http://www.russet.org.uk/blog/3074


ifndef::backend-slidy[]
[NOTE]
====
We test our ontologies explicitly and sometimes very heavily. Tawny-OWL
provides some fixtures to make this easy and we use `core.test` but there
other test frameworks and we might move at some point. This has been written
up as a paper, and I would suggest reading these for further information.
====
endif::backend-slidy[]

== How do you continuously integrate your ontology?

* We can test ontologies with standard frameworks
* These can run directly from leiningen
* This workflow allows the use of standard CI environment with no changes
* We use github/travis-CI
* Note, iff you import ontologies via URI, you may not get a repeatable build.




== What about advanced documentation for Ontologies?

* Tawny-OWL ontologies are readable text
* It is possible to embed rich readable comments
* Also can use literate programming tools
* noweb, or org-mode use traditional approach
* I have also developed "lentic" which integrates with editor

== How do I collaborative develop by ontology?

* The same was as all software
* Version control for asynchronous, fork and merge with git
* Collaborative chat use gerrit, or skype
* Synchronous editing, try floobits, a web editor

== Can I internationalise my ontology?

* Can add internationalised labels

[source,lisp]
----
(label "Ciao" "it")
----

* Can define internationalized function calls

[source,lisp]
----
(defn etichetta [l]
  (label l "it"))
----

* Can use `tawny.polyglot` to use property bundles

== Can I scaffold my ontology from existing source

* Can "import" ontology terms from spreadsheet, XML or a database
* Can work over existing source
* Therefore can generate core of ontology
* And expand it with manually annotated crosslinks

* See paper in ICBO 2015!

== What happens if the labels of read ontologies change

* OBO ontologies use numeric IDs
* These are unreadable, so we syntactically transform labels
* If label changes (but ID remains the same) is a problem
* Can use `tawny.memorize` to remember mappings
* Then add aliases to those now missing (with optional "deprecated" warnings)

== How do you convert an existing ontology to Tawny

* `tawny.render` can perform a syntactic transformation
* Given OWL provides equivalent Clojure code
* Used interactively to provide documentation
* Can be used to port an ontology
* Currently "patternising" ontology is manual
* See Jennifer Warrenders PhD thesis where we did this with SIO

== How Fast is Tawny

* For raw, un-patternized ontology tawny takes about 2x as reading OWL/XML
* Tested by rendering and load GO
* About 56Mb of lisp
* Loads in about 1min
* Most of excess time is in parsing (Clojure also compiles)
* Patternized ontology would involve less parsing

== Can I integrate more tightly with protege?

* We have build a GUI shell into Protege
* Can also use Protege to open a Clojure REPL via a socket
* Protege then displays directly the state of Tawny
* Good for demonstration
* But a little flaky for normal use
* Having Protege reload an OWL file easier


== How does Tawny affect dependency management with ontologies?

* Clojure uses maven dependency management
* We can now publish ontologies as maven artefacts
* And specify dependencies, with versions, and tooling
* Can publish on Maven central or Clojars (no infrastructure to maintain!)
* Separates ID and download location -- disobeys LOD principles
* But fulfils, SLOD principles.

ifndef::backend-slidy[]
[NOTE]
====
Clojure uses maven dependency management. As a tawny ontology is just a piece
of clojure, we can use the same mechanism with tawny ontologies also. Which
means that we can specify ontological dependencies also. This means we can
specify version ranges (OWL doesn't allow this to my knowledge). And we can
can reuse tooling. We can use leiningin to show us a dependency graph, we can
look for version conflicts, we can exclude duplicates from the transistive
closure.

Interestingly, we can also publish our ontology independently from our IDs.
So, we can get someone else to maintain all the infrastructure for deployment
(including of multiple versions) without having to adopt their identifiers
(like bioportal).

This rather breaks the Linked Open Data (LOD) principles, of course which says
that IDs should resolve. Using maven dependencies we don't need this at
all. But it fulls the SLOD (significant load of dependencies) principle which
says if your software has lots of dependencies *and* lots of different people
maintaining the infrastructure for their availability it is going to break all
the time.
====
endif::backend-slidy[]

== Can I link ontologies into software?

* OWL API objects become first class entities in Clojure
* Can refer to them directly
* We integrated Overtone -- a music generation system
* Added in Tawny-OWL and the Music Ontology
* We now have software that plays a tune
* And provides OWL metadata about that tune
* More to investigate here.

== What's this `:super`? why not `:subclass`?

* Manchester syntax uses `SubClassOf:`
* Tawny uses `:super` for the same purpose!
* Confusing!
* Manchester syntax is actually backward
* In tawny, all frames are `A has :frame B`
* In Manchester `A is a SubClassOf: B`
* http://www.russet.org.uk/blog/2985
